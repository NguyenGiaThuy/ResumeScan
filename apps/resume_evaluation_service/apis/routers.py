import os
import uuid
import logging
import requests
from fastapi import APIRouter, File, HTTPException, Request, UploadFile
from pydantic import BaseModel
from utilities.minio_pdf_helper import MinIOPDFUploader
from core.agents.orchestrator import Orchestrator


router = APIRouter()


# TODO: Outsource the code not related to router to external modules
class DocumentUrls(BaseModel):
    resume_url: str
    jd_url: str


def get_graph_state(resume_uri: str, jd_uri: str) -> dict:
    orchestrator = Orchestrator()
    graph = orchestrator.orchestrate()
    output = graph.invoke(input={"resume_path": resume_uri, "jd_path": jd_uri})

    return output


@router.post("/create_resume_evaluator")
async def create_resume_evaluator(payload: DocumentUrls) -> dict:
    """
    API to receive resume url and JD url
    """
    try:
        orchestrator = Orchestrator()
        graph = orchestrator.orchestrate()
        output = graph.invoke(input={"resume_path": payload.resume_url, "jd_path": payload.jd_url})

        chatbot_url = os.environ["CHATBOT_URL"]
        requests.post(chatbot_url, data=output)

        return {"message": "Successfully"}
    except Exception as e:
        error_id = str(uuid.uuid4())
        logging.error(f"[Error_id]: {error_id} {e}")
        raise HTTPException(status_code=500, detail={"error_id": error_id})


@router.post("/match")
async def match_jd_resume(
    jd_file: UploadFile = File(..., description="Job Description PDF"),
    resume_file: UploadFile = File(..., description="Resume PDF")
):
    """
    Match Job Description with Resume and return compatibility score.
    """
    if not jd_file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="JD file must be a PDF")

    if not resume_file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="Resume file must be a PDF")

    try:
        # TODO: This code should be refactored to outsource the code to services

        # Upload file to minIO
        endpoint_url = os.environ["MINIO_ENDPOINT_URL"]
        region_name = os.environ["MINIO_REGION_NAME"]
        access_key = os.environ["MINIO_ACCESS_KEY"]
        secret_key = os.environ["MINIO_SECRET_KEY"]
        use_ssl = bool(os.environ["MINIO_USE_SSL"])

        resume_uploader = MinIOPDFUploader(
            endpoint_url=endpoint_url,
            region_name=region_name,
            access_key=access_key,
            secret_key=secret_key,
            bucket_name=os.environ["MINIO_RESUME_BUCKET_NAME"],
            use_ssl=use_ssl,
        )
        resume_uri = resume_uploader.upload_fastapi_file(resume_file, object_name=f"{uuid.uuid4()}.pdf")

        jd_uploader = MinIOPDFUploader(
            endpoint_url=endpoint_url,
            region_name=region_name,
            access_key=access_key,
            secret_key=secret_key,
            bucket_name=os.environ["MINIO_JD_BUCKET_NAME"],
            use_ssl=use_ssl,
        )
        jd_uri = jd_uploader.upload_fastapi_file(jd_file, object_name=f"{uuid.uuid4()}.pdf")

        # TODO: Store document urls to DB

        # Get graph state from resume_uri and jd_uri generated by minIO
        graph_state = get_graph_state(resume_uri, jd_uri)

        # Send state to chatbot endpoint
        chatbot_url = os.environ["CHATBOT_URL"]
        requests.post(chatbot_url, data=graph_state)

        return {"message": "Successfully"}
    except Exception as e:
        error_id = str(uuid.uuid4())
        logging.error(f"[Error_id]: {error_id} {e}")
        raise HTTPException(status_code=500, detail={"error_id": error_id})
